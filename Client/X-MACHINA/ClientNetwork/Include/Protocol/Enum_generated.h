// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_ENUM_FBPROTOCOL_H_
#define FLATBUFFERS_GENERATED_ENUM_FBPROTOCOL_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 7,
             "Non-compatible flatbuffers version included");

namespace FBProtocol {

enum OBJECT_TYPE : uint8_t {
  OBJECT_TYPE_NONE = 0,
  OBJECT_TYPE_PLAYER = 1,
  OBJECT_TYPE_MONSTER = 2,
  OBJECT_TYPE_STRUCTURE = 3,
  OBJECT_TYPE_MIN = OBJECT_TYPE_NONE,
  OBJECT_TYPE_MAX = OBJECT_TYPE_STRUCTURE
};

inline const OBJECT_TYPE (&EnumValuesOBJECT_TYPE())[4] {
  static const OBJECT_TYPE values[] = {
    OBJECT_TYPE_NONE,
    OBJECT_TYPE_PLAYER,
    OBJECT_TYPE_MONSTER,
    OBJECT_TYPE_STRUCTURE
  };
  return values;
}

inline const char * const *EnumNamesOBJECT_TYPE() {
  static const char * const names[5] = {
    "NONE",
    "PLAYER",
    "MONSTER",
    "STRUCTURE",
    nullptr
  };
  return names;
}

inline const char *EnumNameOBJECT_TYPE(OBJECT_TYPE e) {
  if (::flatbuffers::IsOutRange(e, OBJECT_TYPE_NONE, OBJECT_TYPE_STRUCTURE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesOBJECT_TYPE()[index];
}

enum MONSTER_TYPE : uint8_t {
  MONSTER_TYPE_ADVANCED_COMBAT_DROIR_5 = 0,
  MONSTER_TYPE_ANGLEROX = 1,
  MONSTER_TYPE_ARACK = 2,
  MONSTER_TYPE_ARANOBOT = 3,
  MONSTER_TYPE_CERATOFEROX = 4,
  MONSTER_TYPE_GOBBLER = 5,
  MONSTER_TYPE_LIGHTBIPEDMECH = 6,
  MONSTER_TYPE_MININGMECH = 7,
  MONSTER_TYPE_ONYSCIDUS = 8,
  MONSTER_TYPE_URSACETUS = 9,
  MONSTER_TYPE_RAPAX = 10,
  MONSTER_TYPE_DEUS_PHASE_1 = 11,
  MONSTER_TYPE_DEUS_PHASE_2 = 12,
  MONSTER_TYPE_END = 13,
  MONSTER_TYPE_MIN = MONSTER_TYPE_ADVANCED_COMBAT_DROIR_5,
  MONSTER_TYPE_MAX = MONSTER_TYPE_END
};

inline const MONSTER_TYPE (&EnumValuesMONSTER_TYPE())[14] {
  static const MONSTER_TYPE values[] = {
    MONSTER_TYPE_ADVANCED_COMBAT_DROIR_5,
    MONSTER_TYPE_ANGLEROX,
    MONSTER_TYPE_ARACK,
    MONSTER_TYPE_ARANOBOT,
    MONSTER_TYPE_CERATOFEROX,
    MONSTER_TYPE_GOBBLER,
    MONSTER_TYPE_LIGHTBIPEDMECH,
    MONSTER_TYPE_MININGMECH,
    MONSTER_TYPE_ONYSCIDUS,
    MONSTER_TYPE_URSACETUS,
    MONSTER_TYPE_RAPAX,
    MONSTER_TYPE_DEUS_PHASE_1,
    MONSTER_TYPE_DEUS_PHASE_2,
    MONSTER_TYPE_END
  };
  return values;
}

inline const char * const *EnumNamesMONSTER_TYPE() {
  static const char * const names[15] = {
    "ADVANCED_COMBAT_DROIR_5",
    "ANGLEROX",
    "ARACK",
    "ARANOBOT",
    "CERATOFEROX",
    "GOBBLER",
    "LIGHTBIPEDMECH",
    "MININGMECH",
    "ONYSCIDUS",
    "URSACETUS",
    "RAPAX",
    "DEUS_PHASE_1",
    "DEUS_PHASE_2",
    "END",
    nullptr
  };
  return names;
}

inline const char *EnumNameMONSTER_TYPE(MONSTER_TYPE e) {
  if (::flatbuffers::IsOutRange(e, MONSTER_TYPE_ADVANCED_COMBAT_DROIR_5, MONSTER_TYPE_END)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMONSTER_TYPE()[index];
}

enum MONSTER_BT_TYPE : uint8_t {
  MONSTER_BT_TYPE_IDLE = 0,
  MONSTER_BT_TYPE_DEATH = 1,
  MONSTER_BT_TYPE_ATTACK = 2,
  MONSTER_BT_TYPE_GETHIT = 3,
  MONSTER_BT_TYPE_MOVE_TO_TARGET = 4,
  MONSTER_BT_TYPE_MOVE_TO_PATH = 5,
  MONSTER_BT_TYPE_MOVE_TO_MIND_TARGET = 6,
  MONSTER_BT_TYPE_PATROL = 7,
  MONSTER_BT_TYPE_CHANGE_BT = 8,
  MONSTER_BT_TYPE_END = 9,
  MONSTER_BT_TYPE_MIN = MONSTER_BT_TYPE_IDLE,
  MONSTER_BT_TYPE_MAX = MONSTER_BT_TYPE_END
};

inline const MONSTER_BT_TYPE (&EnumValuesMONSTER_BT_TYPE())[10] {
  static const MONSTER_BT_TYPE values[] = {
    MONSTER_BT_TYPE_IDLE,
    MONSTER_BT_TYPE_DEATH,
    MONSTER_BT_TYPE_ATTACK,
    MONSTER_BT_TYPE_GETHIT,
    MONSTER_BT_TYPE_MOVE_TO_TARGET,
    MONSTER_BT_TYPE_MOVE_TO_PATH,
    MONSTER_BT_TYPE_MOVE_TO_MIND_TARGET,
    MONSTER_BT_TYPE_PATROL,
    MONSTER_BT_TYPE_CHANGE_BT,
    MONSTER_BT_TYPE_END
  };
  return values;
}

inline const char * const *EnumNamesMONSTER_BT_TYPE() {
  static const char * const names[11] = {
    "IDLE",
    "DEATH",
    "ATTACK",
    "GETHIT",
    "MOVE_TO_TARGET",
    "MOVE_TO_PATH",
    "MOVE_TO_MIND_TARGET",
    "PATROL",
    "CHANGE_BT",
    "END",
    nullptr
  };
  return names;
}

inline const char *EnumNameMONSTER_BT_TYPE(MONSTER_BT_TYPE e) {
  if (::flatbuffers::IsOutRange(e, MONSTER_BT_TYPE_IDLE, MONSTER_BT_TYPE_END)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMONSTER_BT_TYPE()[index];
}

enum PLAYER_MOTION_STATE_TYPE : uint8_t {
  PLAYER_MOTION_STATE_TYPE_NONE = 0,
  PLAYER_MOTION_STATE_TYPE_STAND = 1,
  PLAYER_MOTION_STATE_TYPE_SIT = 2,
  PLAYER_MOTION_STATE_TYPE_WALK = 3,
  PLAYER_MOTION_STATE_TYPE_RUN = 4,
  PLAYER_MOTION_STATE_TYPE_SPRINT = 5,
  PLAYER_MOTION_STATE_TYPE_END = 6,
  PLAYER_MOTION_STATE_TYPE_MIN = PLAYER_MOTION_STATE_TYPE_NONE,
  PLAYER_MOTION_STATE_TYPE_MAX = PLAYER_MOTION_STATE_TYPE_END
};

inline const PLAYER_MOTION_STATE_TYPE (&EnumValuesPLAYER_MOTION_STATE_TYPE())[7] {
  static const PLAYER_MOTION_STATE_TYPE values[] = {
    PLAYER_MOTION_STATE_TYPE_NONE,
    PLAYER_MOTION_STATE_TYPE_STAND,
    PLAYER_MOTION_STATE_TYPE_SIT,
    PLAYER_MOTION_STATE_TYPE_WALK,
    PLAYER_MOTION_STATE_TYPE_RUN,
    PLAYER_MOTION_STATE_TYPE_SPRINT,
    PLAYER_MOTION_STATE_TYPE_END
  };
  return values;
}

inline const char * const *EnumNamesPLAYER_MOTION_STATE_TYPE() {
  static const char * const names[8] = {
    "NONE",
    "STAND",
    "SIT",
    "WALK",
    "RUN",
    "SPRINT",
    "END",
    nullptr
  };
  return names;
}

inline const char *EnumNamePLAYER_MOTION_STATE_TYPE(PLAYER_MOTION_STATE_TYPE e) {
  if (::flatbuffers::IsOutRange(e, PLAYER_MOTION_STATE_TYPE_NONE, PLAYER_MOTION_STATE_TYPE_END)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPLAYER_MOTION_STATE_TYPE()[index];
}

enum PLAYER_STATE_TYPE : uint8_t {
  PLAYER_STATE_TYPE_NONE = 0,
  PLAYER_STATE_TYPE_DEACTIVE = 1,
  PLAYER_STATE_TYPE_ACTIVE = 2,
  PLAYER_STATE_TYPE_DEAD = 3,
  PLAYER_STATE_TYPE_END = 4,
  PLAYER_STATE_TYPE_MIN = PLAYER_STATE_TYPE_NONE,
  PLAYER_STATE_TYPE_MAX = PLAYER_STATE_TYPE_END
};

inline const PLAYER_STATE_TYPE (&EnumValuesPLAYER_STATE_TYPE())[5] {
  static const PLAYER_STATE_TYPE values[] = {
    PLAYER_STATE_TYPE_NONE,
    PLAYER_STATE_TYPE_DEACTIVE,
    PLAYER_STATE_TYPE_ACTIVE,
    PLAYER_STATE_TYPE_DEAD,
    PLAYER_STATE_TYPE_END
  };
  return values;
}

inline const char * const *EnumNamesPLAYER_STATE_TYPE() {
  static const char * const names[6] = {
    "NONE",
    "DEACTIVE",
    "ACTIVE",
    "DEAD",
    "END",
    nullptr
  };
  return names;
}

inline const char *EnumNamePLAYER_STATE_TYPE(PLAYER_STATE_TYPE e) {
  if (::flatbuffers::IsOutRange(e, PLAYER_STATE_TYPE_NONE, PLAYER_STATE_TYPE_END)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPLAYER_STATE_TYPE()[index];
}

enum PLAYER_SKILL_TYPE : uint8_t {
  PLAYER_SKILL_TYPE_IMPOSSIBLE = 0,
  PLAYER_SKILL_TYPE_CLOACKING = 1,
  PLAYER_SKILL_TYPE_IR_DETECTOR = 2,
  PLAYER_SKILL_TYPE_MIND_CONTROL = 3,
  PLAYER_SKILL_TYPE_SHIELD = 4,
  PLAYER_SKILL_TYPE_END = 5,
  PLAYER_SKILL_TYPE_MIN = PLAYER_SKILL_TYPE_IMPOSSIBLE,
  PLAYER_SKILL_TYPE_MAX = PLAYER_SKILL_TYPE_END
};

inline const PLAYER_SKILL_TYPE (&EnumValuesPLAYER_SKILL_TYPE())[6] {
  static const PLAYER_SKILL_TYPE values[] = {
    PLAYER_SKILL_TYPE_IMPOSSIBLE,
    PLAYER_SKILL_TYPE_CLOACKING,
    PLAYER_SKILL_TYPE_IR_DETECTOR,
    PLAYER_SKILL_TYPE_MIND_CONTROL,
    PLAYER_SKILL_TYPE_SHIELD,
    PLAYER_SKILL_TYPE_END
  };
  return values;
}

inline const char * const *EnumNamesPLAYER_SKILL_TYPE() {
  static const char * const names[7] = {
    "IMPOSSIBLE",
    "CLOACKING",
    "IR_DETECTOR",
    "MIND_CONTROL",
    "SHIELD",
    "END",
    nullptr
  };
  return names;
}

inline const char *EnumNamePLAYER_SKILL_TYPE(PLAYER_SKILL_TYPE e) {
  if (::flatbuffers::IsOutRange(e, PLAYER_SKILL_TYPE_IMPOSSIBLE, PLAYER_SKILL_TYPE_END)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPLAYER_SKILL_TYPE()[index];
}

enum ITEM_TYPE : uint8_t {
  ITEM_TYPE_NONE = 0,
  ITEM_TYPE_STATIC_ITEM = 1,
  ITEM_TYPE_DYNAMIC_ITEM = 2,
  ITEM_TYPE_STATIC_ITEM_CRATE = 3,
  ITEM_TYPE_WEAPON_H_LOOK = 4,
  ITEM_TYPE_WEAPON_DBMS = 5,
  ITEM_TYPE_WEAPON_STUART = 6,
  ITEM_TYPE_WEAPON_DESCRIPTOR = 7,
  ITEM_TYPE_WEAPON_T_12 = 8,
  ITEM_TYPE_WEAPON_PIPELINE = 9,
  ITEM_TYPE_WEAPON_BURNOUT = 10,
  ITEM_TYPE_WEAPON_DIRECT_DRAIN = 11,
  ITEM_TYPE_WEAPON_MINE_LAUNCHER = 12,
  ITEM_TYPE_WEAPON_SKYLINE = 13,
  ITEM_TYPE_WEAPON_AIR_STRIKE = 14,
  ITEM_TYPE_MIN = ITEM_TYPE_NONE,
  ITEM_TYPE_MAX = ITEM_TYPE_WEAPON_AIR_STRIKE
};

inline const ITEM_TYPE (&EnumValuesITEM_TYPE())[15] {
  static const ITEM_TYPE values[] = {
    ITEM_TYPE_NONE,
    ITEM_TYPE_STATIC_ITEM,
    ITEM_TYPE_DYNAMIC_ITEM,
    ITEM_TYPE_STATIC_ITEM_CRATE,
    ITEM_TYPE_WEAPON_H_LOOK,
    ITEM_TYPE_WEAPON_DBMS,
    ITEM_TYPE_WEAPON_STUART,
    ITEM_TYPE_WEAPON_DESCRIPTOR,
    ITEM_TYPE_WEAPON_T_12,
    ITEM_TYPE_WEAPON_PIPELINE,
    ITEM_TYPE_WEAPON_BURNOUT,
    ITEM_TYPE_WEAPON_DIRECT_DRAIN,
    ITEM_TYPE_WEAPON_MINE_LAUNCHER,
    ITEM_TYPE_WEAPON_SKYLINE,
    ITEM_TYPE_WEAPON_AIR_STRIKE
  };
  return values;
}

inline const char * const *EnumNamesITEM_TYPE() {
  static const char * const names[16] = {
    "NONE",
    "STATIC_ITEM",
    "DYNAMIC_ITEM",
    "STATIC_ITEM_CRATE",
    "WEAPON_H_LOOK",
    "WEAPON_DBMS",
    "WEAPON_STUART",
    "WEAPON_DESCRIPTOR",
    "WEAPON_T_12",
    "WEAPON_PIPELINE",
    "WEAPON_BURNOUT",
    "WEAPON_DIRECT_DRAIN",
    "WEAPON_MINE_LAUNCHER",
    "WEAPON_SKYLINE",
    "WEAPON_AIR_STRIKE",
    nullptr
  };
  return names;
}

inline const char *EnumNameITEM_TYPE(ITEM_TYPE e) {
  if (::flatbuffers::IsOutRange(e, ITEM_TYPE_NONE, ITEM_TYPE_WEAPON_AIR_STRIKE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesITEM_TYPE()[index];
}

}  // namespace FBProtocol

#endif  // FLATBUFFERS_GENERATED_ENUM_FBPROTOCOL_H_
