// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_ENUM_FBPROTOCOL_H_
#define FLATBUFFERS_GENERATED_ENUM_FBPROTOCOL_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 7,
             "Non-compatible flatbuffers version included");

namespace FBProtocol {

enum OBJECT_TYPE : uint8_t {
  OBJECT_TYPE_NONE = 0,
  OBJECT_TYPE_PLAYER = 1,
  OBJECT_TYPE_MONSTER = 2,
  OBJECT_TYPE_STRUCTURE = 3,
  OBJECT_TYPE_MIN = OBJECT_TYPE_NONE,
  OBJECT_TYPE_MAX = OBJECT_TYPE_STRUCTURE
};

inline const OBJECT_TYPE (&EnumValuesOBJECT_TYPE())[4] {
  static const OBJECT_TYPE values[] = {
    OBJECT_TYPE_NONE,
    OBJECT_TYPE_PLAYER,
    OBJECT_TYPE_MONSTER,
    OBJECT_TYPE_STRUCTURE
  };
  return values;
}

inline const char * const *EnumNamesOBJECT_TYPE() {
  static const char * const names[5] = {
    "NONE",
    "PLAYER",
    "MONSTER",
    "STRUCTURE",
    nullptr
  };
  return names;
}

inline const char *EnumNameOBJECT_TYPE(OBJECT_TYPE e) {
  if (::flatbuffers::IsOutRange(e, OBJECT_TYPE_NONE, OBJECT_TYPE_STRUCTURE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesOBJECT_TYPE()[index];
}

enum WEAPON_TYPE : uint8_t {
  WEAPON_TYPE_H_LOOK = 0,
  WEAPON_TYPE_DBMS = 1,
  WEAPON_TYPE_STUART = 2,
  WEAPON_TYPE_DESCRIPTOR = 3,
  WEAPON_TYPE_T_12 = 4,
  WEAPON_TYPE_PIPELINE = 5,
  WEAPON_TYPE_BURNOUT = 6,
  WEAPON_TYPE_DIRECT_DRAIN = 7,
  WEAPON_TYPE_MIN = WEAPON_TYPE_H_LOOK,
  WEAPON_TYPE_MAX = WEAPON_TYPE_DIRECT_DRAIN
};

inline const WEAPON_TYPE (&EnumValuesWEAPON_TYPE())[8] {
  static const WEAPON_TYPE values[] = {
    WEAPON_TYPE_H_LOOK,
    WEAPON_TYPE_DBMS,
    WEAPON_TYPE_STUART,
    WEAPON_TYPE_DESCRIPTOR,
    WEAPON_TYPE_T_12,
    WEAPON_TYPE_PIPELINE,
    WEAPON_TYPE_BURNOUT,
    WEAPON_TYPE_DIRECT_DRAIN
  };
  return values;
}

inline const char * const *EnumNamesWEAPON_TYPE() {
  static const char * const names[9] = {
    "H_LOOK",
    "DBMS",
    "STUART",
    "DESCRIPTOR",
    "T_12",
    "PIPELINE",
    "BURNOUT",
    "DIRECT_DRAIN",
    nullptr
  };
  return names;
}

inline const char *EnumNameWEAPON_TYPE(WEAPON_TYPE e) {
  if (::flatbuffers::IsOutRange(e, WEAPON_TYPE_H_LOOK, WEAPON_TYPE_DIRECT_DRAIN)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesWEAPON_TYPE()[index];
}

enum MONSTER_TYPE : uint8_t {
  MONSTER_TYPE_ADVANCED_COMBAT_DROIR_5 = 0,
  MONSTER_TYPE_ANGLEROX = 1,
  MONSTER_TYPE_ARACK = 2,
  MONSTER_TYPE_ARANOBOT = 3,
  MONSTER_TYPE_CERATOFEROX = 4,
  MONSTER_TYPE_GOBBLER = 5,
  MONSTER_TYPE_LIGHTBIPEDMECH = 6,
  MONSTER_TYPE_MININGMECH = 7,
  MONSTER_TYPE_ONYSCIDUS = 8,
  MONSTER_TYPE_URSACETUS = 9,
  MONSTER_TYPE_RAPAX = 10,
  MONSTER_TYPE_MIN = MONSTER_TYPE_ADVANCED_COMBAT_DROIR_5,
  MONSTER_TYPE_MAX = MONSTER_TYPE_RAPAX
};

inline const MONSTER_TYPE (&EnumValuesMONSTER_TYPE())[11] {
  static const MONSTER_TYPE values[] = {
    MONSTER_TYPE_ADVANCED_COMBAT_DROIR_5,
    MONSTER_TYPE_ANGLEROX,
    MONSTER_TYPE_ARACK,
    MONSTER_TYPE_ARANOBOT,
    MONSTER_TYPE_CERATOFEROX,
    MONSTER_TYPE_GOBBLER,
    MONSTER_TYPE_LIGHTBIPEDMECH,
    MONSTER_TYPE_MININGMECH,
    MONSTER_TYPE_ONYSCIDUS,
    MONSTER_TYPE_URSACETUS,
    MONSTER_TYPE_RAPAX
  };
  return values;
}

inline const char * const *EnumNamesMONSTER_TYPE() {
  static const char * const names[12] = {
    "ADVANCED_COMBAT_DROIR_5",
    "ANGLEROX",
    "ARACK",
    "ARANOBOT",
    "CERATOFEROX",
    "GOBBLER",
    "LIGHTBIPEDMECH",
    "MININGMECH",
    "ONYSCIDUS",
    "URSACETUS",
    "RAPAX",
    nullptr
  };
  return names;
}

inline const char *EnumNameMONSTER_TYPE(MONSTER_TYPE e) {
  if (::flatbuffers::IsOutRange(e, MONSTER_TYPE_ADVANCED_COMBAT_DROIR_5, MONSTER_TYPE_RAPAX)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMONSTER_TYPE()[index];
}

enum MONSTER_BT_TYPE : uint8_t {
  MONSTER_BT_TYPE_DEATH = 0,
  MONSTER_BT_TYPE_ATTACK = 1,
  MONSTER_BT_TYPE_GETHIT = 2,
  MONSTER_BT_TYPE_MOVE_TO_TARGET = 3,
  MONSTER_BT_TYPE_MOVE_TO_PATH = 4,
  MONSTER_BT_TYPE_PATROL = 5,
  MONSTER_BT_TYPE_MIN = MONSTER_BT_TYPE_DEATH,
  MONSTER_BT_TYPE_MAX = MONSTER_BT_TYPE_PATROL
};

inline const MONSTER_BT_TYPE (&EnumValuesMONSTER_BT_TYPE())[6] {
  static const MONSTER_BT_TYPE values[] = {
    MONSTER_BT_TYPE_DEATH,
    MONSTER_BT_TYPE_ATTACK,
    MONSTER_BT_TYPE_GETHIT,
    MONSTER_BT_TYPE_MOVE_TO_TARGET,
    MONSTER_BT_TYPE_MOVE_TO_PATH,
    MONSTER_BT_TYPE_PATROL
  };
  return values;
}

inline const char * const *EnumNamesMONSTER_BT_TYPE() {
  static const char * const names[7] = {
    "DEATH",
    "ATTACK",
    "GETHIT",
    "MOVE_TO_TARGET",
    "MOVE_TO_PATH",
    "PATROL",
    nullptr
  };
  return names;
}

inline const char *EnumNameMONSTER_BT_TYPE(MONSTER_BT_TYPE e) {
  if (::flatbuffers::IsOutRange(e, MONSTER_BT_TYPE_DEATH, MONSTER_BT_TYPE_PATROL)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMONSTER_BT_TYPE()[index];
}

enum PLAYER_MOTION_STATE_TYPE : uint8_t {
  PLAYER_MOTION_STATE_TYPE_NONE = 0,
  PLAYER_MOTION_STATE_TYPE_STAND = 1,
  PLAYER_MOTION_STATE_TYPE_SIT = 2,
  PLAYER_MOTION_STATE_TYPE_WALK = 3,
  PLAYER_MOTION_STATE_TYPE_RUN = 4,
  PLAYER_MOTION_STATE_TYPE_SPRINT = 5,
  PLAYER_MOTION_STATE_TYPE_MIN = PLAYER_MOTION_STATE_TYPE_NONE,
  PLAYER_MOTION_STATE_TYPE_MAX = PLAYER_MOTION_STATE_TYPE_SPRINT
};

inline const PLAYER_MOTION_STATE_TYPE (&EnumValuesPLAYER_MOTION_STATE_TYPE())[6] {
  static const PLAYER_MOTION_STATE_TYPE values[] = {
    PLAYER_MOTION_STATE_TYPE_NONE,
    PLAYER_MOTION_STATE_TYPE_STAND,
    PLAYER_MOTION_STATE_TYPE_SIT,
    PLAYER_MOTION_STATE_TYPE_WALK,
    PLAYER_MOTION_STATE_TYPE_RUN,
    PLAYER_MOTION_STATE_TYPE_SPRINT
  };
  return values;
}

inline const char * const *EnumNamesPLAYER_MOTION_STATE_TYPE() {
  static const char * const names[7] = {
    "NONE",
    "STAND",
    "SIT",
    "WALK",
    "RUN",
    "SPRINT",
    nullptr
  };
  return names;
}

inline const char *EnumNamePLAYER_MOTION_STATE_TYPE(PLAYER_MOTION_STATE_TYPE e) {
  if (::flatbuffers::IsOutRange(e, PLAYER_MOTION_STATE_TYPE_NONE, PLAYER_MOTION_STATE_TYPE_SPRINT)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPLAYER_MOTION_STATE_TYPE()[index];
}

enum PLAYER_SKILL_TYPE : uint8_t {
  PLAYER_SKILL_TYPE_IMPOSSIBLE = 0,
  PLAYER_SKILL_TYPE_CLOACKING = 1,
  PLAYER_SKILL_TYPE_IR_DETECTOR = 2,
  PLAYER_SKILL_TYPE_MIND_CONTROL = 3,
  PLAYER_SKILL_TYPE_SHIELD = 4,
  PLAYER_SKILL_TYPE_MIN = PLAYER_SKILL_TYPE_IMPOSSIBLE,
  PLAYER_SKILL_TYPE_MAX = PLAYER_SKILL_TYPE_SHIELD
};

inline const PLAYER_SKILL_TYPE (&EnumValuesPLAYER_SKILL_TYPE())[5] {
  static const PLAYER_SKILL_TYPE values[] = {
    PLAYER_SKILL_TYPE_IMPOSSIBLE,
    PLAYER_SKILL_TYPE_CLOACKING,
    PLAYER_SKILL_TYPE_IR_DETECTOR,
    PLAYER_SKILL_TYPE_MIND_CONTROL,
    PLAYER_SKILL_TYPE_SHIELD
  };
  return values;
}

inline const char * const *EnumNamesPLAYER_SKILL_TYPE() {
  static const char * const names[6] = {
    "IMPOSSIBLE",
    "CLOACKING",
    "IR_DETECTOR",
    "MIND_CONTROL",
    "SHIELD",
    nullptr
  };
  return names;
}

inline const char *EnumNamePLAYER_SKILL_TYPE(PLAYER_SKILL_TYPE e) {
  if (::flatbuffers::IsOutRange(e, PLAYER_SKILL_TYPE_IMPOSSIBLE, PLAYER_SKILL_TYPE_SHIELD)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPLAYER_SKILL_TYPE()[index];
}

}  // namespace FBProtocol

#endif  // FLATBUFFERS_GENERATED_ENUM_FBPROTOCOL_H_
