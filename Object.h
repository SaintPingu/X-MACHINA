#pragma once
#include "Component.h"

//-----------------------------[Class Declaration]-----------------------------//
class MasterModel;
class Mesh;
class Camera;
class Texture;

struct LIGHT;
//-----------------------------------------------------------------------------//







//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class ModelObject : public Object {
private:
	/* for UpdateBoundingBox() */
	using Transform::Translate;
	using Transform::Rotate;
	using Transform::SetWorldTransform;
	using Transform::ReturnTransform;

public:
	bool mIsDrawBounding{ false };

public:
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	///// [ Constructor ] /////

	ModelObject();
	virtual ~ModelObject();

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	///// [ Getter ] /////


	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	///// [ Setter ] /////

	/* Position */
	virtual void SetPosition(const Vec3& pos);
	virtual void SetPosition(const XMVECTOR& pos);
	virtual void SetPosition(float x, float y, float z);

	/* Others */

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	///// [ Others ] /////

	/* DirectX */
	virtual void CreateShaderVariables();
	virtual void UpdateShaderVariables() const;
	virtual void ReleaseShaderVariables();
	virtual void ReleaseUploadBuffers();

	/* Movement */
	virtual void Translate(const Vec3& translation);
	virtual void Translate(const Vec3& direction, float distance);
	virtual void Translate(float x, float y, float z);

	virtual void Rotate(float pitch = 0.0f, float yaw = 0.0f, float roll = 0.0f);
	virtual void Rotate(const Vec3& axis, float angle);

	/* Transform */
	void SetWorldTransform(const Vec4x4& transform) override;
	void SetTransform(const Vec4x4& transform) override;

	/* Others */
protected:
	virtual void Update();

public:
	virtual void ToggleDrawBoundings();

	Transform* FindFrame(const std::string& frameName);
	ModelObject* FindObject(const std::string& frameName);

// lights
public:
	/*std::vector<Transform*> mLightPositions;
	LIGHT_RANGE mLightRange{};

	void SetLightRange(LIGHT_RANGE lightRange);
	void SetAllLight(const LIGHT* light);
	size_t GetLightCount() { return mLightPositions.size(); }*/
};



//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


class GameObject : public ModelObject {
private:
	bool mIsAwake{ false };
	bool mIsActive{ true };
	bool mIsFlyable{ false };

	std::unordered_set<int> mGridIndices{};
	int mCrntGridIndex{ -1 };

	std::vector<const Transform*> mMergedTransform{};

protected:
	bool mIsInstancing{ false };

public:
	sptr<const MasterModel> mModel{};

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	///// [ Constructor ] /////

	GameObject();
	virtual ~GameObject();

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	///// [ Getter ] /////
	bool IsActive() const { return mIsActive; }

	int GetGridIndex() const { return mCrntGridIndex; }
	const std::unordered_set<int>& GetGridIndices() const { return mGridIndices; }

	const std::vector<const Transform*>& GetMergedTransform() const { return mMergedTransform; }
	rsptr<Texture> GetTexture() const;

	bool IsTransparent() const;
	bool IsInstancing() const { return mIsInstancing; }

	void SetInstancing() { mIsInstancing = true; }

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	///// [ Setter ] /////

	/* Others */
	void SetFlyable(bool isFlyable);
	void SetGridIndex(int index) { mCrntGridIndex = index; }
	void SetGridIndices(const std::unordered_set<int>& indices) { mGridIndices = indices; }
	void ClearGridIndices() { mGridIndices.clear(); }

	void SetModel(rsptr<const MasterModel> model);

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	///// [ Others ] /////

	/* DirectX */
private:
	void UpdateShaderVariablesSprite();
public:
	virtual void Render();
	virtual void RenderBounds();

	/* Movement */
	virtual void Update();

	/* Others */
private:
	void AttachToGround();
	void TiltToGround();

public:
	virtual void Enable(bool isUpdateObjectGrid = true);
	virtual void Disable(bool isUpdateObjectGrid = true);

};



//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class ObjectInstanceBuffer;
class InstancinObject : public GameObject {

	using GameObject::Render;

private:
	sptr<ObjectInstanceBuffer> mBuffer{};

	std::function<void()> mUpdate{};
	void UpdateStatic();
	void UpdateDynamic();

	bool mIsPushed{ false };
	void Reset() { mIsPushed = false; }
	void Push();

public:
	void SetBuffer(rsptr<ObjectInstanceBuffer> buffer);
	virtual void Render() override;
	virtual void Update() override;
};



//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
struct VS_OBJECT_INSTANCE
{
	Vec4x4 mLocalTransform{};
};

class ObjectInstanceBuffer {
private:
	UINT mObjectCount{};
	sptr<const MasterModel> mModel{};

	std::vector<const Transform*> mMergedTransform{};
	ComPtr<ID3D12Resource> mInstBuffer{};
	VS_OBJECT_INSTANCE* mMappedBuffer{};

	void ResetBuffer() { mCrntBufferIndex = 0; }

protected:
	UINT mCrntBufferIndex{};
	bool mIsStatic{ true };

public:
	void SetDynamic() { mIsStatic = false; }
	void SetModel(rsptr<const MasterModel> model);

	bool IsStatic() { return mIsStatic; }
	UINT GetObjectCount() const { return mObjectCount; }
	UINT GetInstanceCount() const { return mCrntBufferIndex; }
	const std::vector<const Transform*>& GetMergedTransform() const { return mMergedTransform; }

	void PushObject(InstancinObject* object);
	void CreateShaderVariables(UINT objectCount);
	void UpdateShaderVariables() const;
	void Render();
};