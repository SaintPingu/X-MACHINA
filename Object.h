//------------------------------------------------------- ----------------------
// File: Object.h
//-----------------------------------------------------------------------------

#pragma once
#include "Component.h"

class CMasterModel;

// Class Declarations
class CMesh;
class Camera;
class CTexture;

struct LIGHT;







//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class CModelObject : public CObject {
private:
	/* for UpdateBoundingBox() */
	using Transform::Translate;
	using Transform::Rotate;
	using Transform::SetWorldTransform;
	using Transform::ReturnTransform;

public:
	bool mIsDrawBounding{ false };

public:
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	///// [ Constructor ] /////

	CModelObject();
	virtual ~CModelObject();

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	///// [ Getter ] /////


	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	///// [ Setter ] /////

	/* Position */
	virtual void SetPosition(const Vec3& pos);
	virtual void SetPosition(const XMVECTOR& pos);
	virtual void SetPosition(float x, float y, float z);

	/* Others */

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	///// [ Others ] /////

	/* DirectX */
	virtual void CreateShaderVariables();
	virtual void UpdateShaderVariables() const;
	virtual void ReleaseShaderVariables();
	virtual void ReleaseUploadBuffers();

	/* Movement */
	virtual void Translate(const Vec3& translation);
	virtual void Translate(const Vec3& direction, float distance);
	virtual void Translate(float x, float y, float z);

	virtual void Rotate(float pitch = 0.0f, float yaw = 0.0f, float roll = 0.0f);
	virtual void Rotate(const Vec3& axis, float angle);

	/* Transform */
	void SetWorldTransform(const Vec4x4& transform) override;
	void SetTransform(const Vec4x4& transform) override;

	/* Others */
protected:
	virtual void Update();

public:
	virtual void ToggleDrawBoundings();

	Transform* FindFrame(const std::string& frameName);
	CModelObject* FindObject(const std::string& frameName);

// lights
public:
	/*std::vector<Transform*> mLightPositions;
	LIGHT_RANGE mLightRange{};

	void SetLightRange(LIGHT_RANGE lightRange);
	void SetAllLight(const LIGHT* light);
	size_t GetLightCount() { return mLightPositions.size(); }*/
};



//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


class CGameObject : public CModelObject {
private:
	bool mIsAwake{ false };
	bool mIsActive{ true };
	bool mIsFlyable{ false };

	std::unordered_set<int> mGridIndices{};
	int mCrntGridIndex{ -1 };

	std::vector<const Transform*> mMergedTransform{};

protected:
	bool mIsInstancing{ false };

public:
	sptr<const CMasterModel> mModel{};

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	///// [ Constructor ] /////

	CGameObject();
	virtual ~CGameObject();

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	///// [ Getter ] /////
	bool IsActive() const { return mIsActive; }

	int GetGridIndex() const { return mCrntGridIndex; }
	const std::unordered_set<int>& GetGridIndices() const { return mGridIndices; }

	const std::vector<const Transform*>& GetMergedTransform() const { return mMergedTransform; }
	rsptr<CTexture> GetTexture() const;

	bool IsTransparent() const;
	bool IsInstancing() const { return mIsInstancing; }

	void SetInstancing() { mIsInstancing = true; }

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	///// [ Setter ] /////

	///* Direction */
	//void SetMovingDirection(const Vec3& movingDir) { mMovingDir = Vector3::Normalize(movingDir); }
	//void SetMovingDirection(const XMVECTOR& movingDir) { XMStoreFloat3(&mMovingDir, movingDir); }

	///* Moving */
	//void SetMovingSpeed(float speed) { mMovingSpeed = speed; }
	//void SetMovingRange(float range) { mMovingRange = range; }

	/* Others */
	void SetFlyable(bool isFlyable);
	void SetGridIndex(int index) { mCrntGridIndex = index; }
	void SetGridIndices(const std::unordered_set<int>& indices) { mGridIndices = indices; }
	void ClearGridIndices() { mGridIndices.clear(); }

	void SetModel(rsptr<const CMasterModel> model);

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	///// [ Others ] /////

	/* DirectX */
private:
	void UpdateShaderVariablesSprite();
public:
	virtual void Render();
	virtual void RenderBounds();

	/* Movement */
	virtual void Update();

	/* Others */
private:
	void AttachToGround();
	void TiltToGround();

public:
	virtual void Enable(bool isUpdateObjectGrid = true);
	virtual void Disable(bool isUpdateObjectGrid = true);

};



//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class CObjectInstanceBuffer;
class CInstancingObject : public CGameObject {

	using CGameObject::Render;

private:
	sptr<CObjectInstanceBuffer> mBuffer{};

	std::function<void()> mUpdate{};
	void UpdateStatic();
	void UpdateDynamic();

	bool mIsPushed{ false };
	void Reset() { mIsPushed = false; }
	void Push();

public:
	void SetBuffer(rsptr<CObjectInstanceBuffer> buffer);
	virtual void Render() override;
	virtual void Update() override;
};



//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
struct VS_OBJECT_INSTANCE
{
	Vec4x4 mLocalTransform{};
};

class CObjectInstanceBuffer {
private:
	UINT mObjectCount{};
	sptr<const CMasterModel> mModel{};

	std::vector<const Transform*> mMergedTransform{};
	ComPtr<ID3D12Resource> mInstBuffer{};
	VS_OBJECT_INSTANCE* mMappedBuffer{};

	void ResetBuffer() { mCrntBufferIndex = 0; }

protected:
	UINT mCrntBufferIndex{};
	bool mIsStatic{ true };

public:
	void SetDynamic() { mIsStatic = false; }
	void SetModel(rsptr<const CMasterModel> model);

	bool IsStatic() { return mIsStatic; }
	UINT GetObjectCount() const { return mObjectCount; }
	UINT GetInstanceCount() const { return mCrntBufferIndex; }
	const std::vector<const Transform*>& GetMergedTransform() const { return mMergedTransform; }

	void PushObject(CInstancingObject* object);
	void CreateShaderVariables(UINT objectCount);
	void UpdateShaderVariables() const;
	void Render();
};